<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[js类型检测方法汇总]]></title>
    <url>%2F2018%2F10%2F10%2F1%2F</url>
    <content type="text"><![CDATA[js检测数据类型的方法有很多种，例如:typeof、instanceof、 constructor、 prototype等。那这些方法的使用场景有哪些? 只有掌握了这些我们才可以选择最合适的方法使用，达到事半功倍的效果。 首先我们来了解下Javascript的类型有哪些： 基本类型(undefined、null、boolean、number和string, ES6中还新增了Symbol) 引用类型(对象、数组、函数)。但在JavaScript中用户定义的类型(object)并没有类的声明，因此继承关系只能通过构造函数和原型链接来检查。 一.typeof1234567891011121314151617181920// 基本类型typeof undefined "undefined"typeof null "object"typeof true "boolean"typeof 1 "number"typeof "abc" "string"typeof Symbol() "symbol"// 引用类型typeof &#123;a:1&#125; "object"function foo()&#123; console.log(this)&#125;typeof foo "function"typeof (&#123;a:1&#125;) "object"typeof ([]) "object"typeof (new RegExp) "object"typeof (new Date) "object" 通过上面的输出结果，大家不难得出结论，typeof主要用来区分：基本数据类型和引用数据类型 typeof的缺点： 对于nulll类型的判断出现了偏差(其实null不是一个空引用, 其实这是一个js原生的bug) 在校验引用类型的时候，通过typeof得到的结果都是&quot;object&quot;,无法分辨究竟是数组，还是对象，不能进一步区分引用类型 二.instanceofinstanceof操作符用于检测某个对象的原型链是否包含某个构造函数的prototype属性。instanceof是通过原型链来检查类型的,因此对基本的数据类型是不起作用的。（基本的数据类型没有原型链） 12345678[1,2,3] instanceof Array // truenew Date() instanceof Date // truenew RegExp(`\W+`) instanceof RegExp // truefunction foo()&#123; connsole.log(this)&#125;foo instanceof Function // true 与 typeof 方法不同，instanceof只适用于校验变量是否是某一种类型，对于校验未知的类型，要多次判断。 12345if(unknown instanceof Array) &#123; console.log('Array');&#125;else if(unknown instanceof Date) &#123; console.log('Date');&#125;.... instanceof总结 instanceof适用于校验变量是否是某一种类型 instanceof不适用于校验未知类型的变量，因为需要逐个比对，操作繁琐。 下面来简单的说下instanceof的原理：instanceof 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 prototype。 123456789101112131415// 用于检测某个对象的原型链是否包含某个构造函数的prototypefunction instanceof(left, right) &#123; // 获得类型的原型 let prototype = right.prototype // 获得对象的原型 left = left.__proto__ // 判断对象的类型是否等于类型的原型 while (true) &#123; if (left === null) return false if (prototype === left) return true left = left.__proto__ &#125;&#125; 自定义类型的检测： 12345678910// 比如直接原型关系 function Animal () &#123;&#125;; var a = new Animal(); a instanceof Animal; // =&gt; true // 原型链上的间接原型 function Cat() &#123;&#125;; Cat.prototype = new Animal; var b = new Cat(); b instanceof Animal; // =&gt;true 三.constructorconstructor返回当前对象的构造函数,很灵活，即便不知道变量的具体类型，只需要调用一次constructor就可以得到它是由哪个类创建而成。 123456789101112131415[1,2,3].constructor// ƒ Array() &#123; [native code] &#125;[1,2,3].constructor === Array// true(new Date()).constructor// ƒ Date() &#123; [native code] &#125;(new Date()).constructor === Date// truefunction foo()&#123; console.log(this)&#125;foo.constructor// ƒ Function() &#123; [native code] &#125; constructor存在问题：如果出现原型继承的情况，constructor的结果会出错。 123456function C()&#123;&#125;function D()&#123;&#125;C.prototype = new D(); // C继承自Dvar c = new C();console.log(c.constructor === C);// falseconsole.log(c.constructor === D);// true constructor总结优点：可以对未知类型的数据类型进行判断缺点：如果出现原型继承的情况，constructor的结果会出错 constructor指向最初创建者，而且易于伪造，不适合用来判断变量类型。 null 和 undefined 使用constructor会报异常 四.Object.prototype.toString.callObject.prototype.toString.call可以弥补上面方法的不足，实现完美的类型检测。 在详细介绍之前，先普及一个知识点：javascript的Object对象的toString方法会返回一个表示该对象的字符串，因此我们可以通过toString来检验数据的类型 123let obj = new Object();obj.toString(); // 返回 [object Object] 具体的检验结果： 123456789101112131415161718192021222324252627282930// 1.判断基本类型Object.prototype.toString.call(null)// "[object Null]"Object.prototype.toString.call(undefined)// "[object Undefined]"Object.prototype.toString.call("abc")// "[object String]"Object.prototype.toString.call(true)// "[object Boolean]"// 2.判断引用类型Object.prototype.toString.call(function()&#123;&#125;)// "[object Function]"Object.prototype.toString.call(new Date())// "[object Date]"function C()&#123;&#125;function D()&#123;&#125;C.prototype = new D();var c = new C();Object.prototype.toString.call(C)// "[object Function]"Object.prototype.toString.call(D)// "[object Function]" 可以看出，Object.prototype.toString.call()能够很好的检测基本数据类型和引用数据类型。 jquery和requirejs中都是使用该方法进行的类型检测的。 toString存在的缺陷：无法检测用户自定义类型，他只能检测出ECMA标准中的那些内置类型。 自定义类型： 123456function Person(name, age) &#123; this.name = name; this.age = age;&#125;var person = new Person("Rose", 18);Object.prototype.toString.call(arr); //”[object Object]” 很明显这种方法不能准确判断person是Person类的实例，而只能用instanceof 操作符来进行判断，如下所示： 1console.log(person instanceof Person);//输出结果为true 在JavaScrit中，可以通过创建一个函数，并且通过一些正则表达式，让这个函数实现一个改进版本的typeof 12345678function toType (obj) &#123; // 分割 [object Function] return (&#123;&#125;).toString.call(obj).match(/\s([a-zA-Z]+)/)[1].toLowerCase(); &#125;toType(console.log)// 输出的结果 ：function 参考原理 扩展： toString() 能将某一个值转化为字符串的方法。 为什么不直接使用toString()？ 1234567console.log("jerry".toString());//jerryconsole.log((1).toString());//1console.log([1,2].toString());//1,2console.log(new Date().toString());//Wed Dec 21 2016 20:35:48 GMT+0800 (中国标准时间)console.log(function()&#123;&#125;.toString());//function ()&#123;&#125;console.log(null.toString());//errorconsole.log(undefined.toString());//error 同样是检测对象obj调用toString方法（关于toString()方法的用法的可以参考toString的详解），obj.toString()的结果和Object.prototype.toString.call(obj)的结果不一样，这是为什么？ 这是因为toString为Object的原型方法，而Array ，function等类型作为Object的实例，都重写了toString方法。不同的对象类型调用toString方法时，根据原型链的知识，调用的是对应的重写之后的toString方法（function类型返回内容为函数体的字符串，Array类型返回元素组成的字符串…..），而不会去调用Object上原型toString方法（返回对象的具体类型），所以采用obj.toString()不能得到其对象类型，只能将obj转换为字符串类型；因此，在想要得到对象的具体类型时，应该调用Object上原型toString方法。 我们可以验证一下，将数组的toString方法删除，看看会是什么结果： 123456var arr=[1,2,3];console.log(Array.prototype.hasOwnProperty("toString"));//trueconsole.log(arr.toString());//1,2,3delete Array.prototype.toString;//delete操作符可以删除实例属性console.log(Array.prototype.hasOwnProperty("toString"));//falseconsole.log(arr.toString());//"[object Array]" 删除了Array的toString方法后，同样再采用arr.toString()方法调用时，不再有屏蔽Object原型方法的实例方法，因此沿着原型链，arr最后调用了Object的toString方法，返回了和Object.prototype.toString.call(arr)相同的结果。 为什么要使用call ???? call apply bind 这些都是可以的 javascript中Object有个toString方法,该方法返回一个表示该对象的字符串 , 但是很多对象(如:Array等)都重写了toString方法，所以需要以call或apply的形式来配合使用才最安全。 call / apply / bind 的区别]]></content>
  </entry>
  <entry>
    <title><![CDATA[模版]]></title>
    <url>%2F2018%2F10%2F09%2F1%2F</url>
    <content type="text"><![CDATA[铅笔 这里是文章的简要介绍 人生乃是一面镜子，从镜子里认识自己，我要称之为头等大事，也只是我们追求的目的！ 代码片段 12console.log(123) 123- auto_detect: false+ auto_detect: true defaultprimarysuccessinfowarningdangerdanger no-icon default primary success info warning danger 选项卡 1选项卡 2选项卡 3这是选项卡 1 呵呵哈哈哈哈哈哈哈哈呵呵哈哈哈哈哈哈哈哈呵呵哈哈哈哈哈哈哈哈呵呵哈哈哈哈哈哈哈哈呵呵哈哈哈哈哈哈哈哈呵呵哈哈哈哈哈哈哈哈……这是选项卡 2这是选项卡 3 哇，你找到我了！φ(≧ω≦*)♪～ 内容 1. ## ## ##]]></content>
  </entry>
</search>
